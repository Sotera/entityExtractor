// def: find stored feed data and send to ner
'use strict';
const spawn = require('child_process').spawn;
try {
  require('dotenv').config({silent: true});
} catch(ex) {}

const API_ROOT = process.env.API_ROOT;

if (!API_ROOT) {
  throw new Error('Missing required API_ROOT env var');
}

const request = require('request'),
  _ = require('lodash'),
  JobSetCheckInterval = 5000; //ms

let app,
    interval,
    findEventsInterval = 300 *60 * 1000,
    currentJob,
    lastEndTime = 0,
    SocialMediaPost,
    Event,
    JobSet;


const worker = module.exports = {
  start(appObject) {
    app = appObject;
    SocialMediaPost = app.models.SocialMediaPost;
    Event = app.models.Event;
    JobSet = app.models.JobSet;

    run();
    function run() {
      interval = setInterval(function(){
        checkJobSetStatus();
      },JobSetCheckInterval);
    }
  }
};

function catchUpToEventsIfPossible(){
  return new Promise(
    function (resolve, reject) {
        let args = {
          where: {
            end_time_ms:{
              gt:lastEndTime
            }
          }};

        Event.findOne(args)
          .then(function(model, err){
            if(err != null){
              reject(err);
              return;
            }
            if(!model){
              resolve(null);
              return;
            }
            resolve(model.end_time_ms + 1);
          });

    });

}
function calculateJobsetTimes(startTime){
  return new Promise(
    function (resolve, reject) {
      if (!startTime) {
        //find the first job set and get the start time
        JobSet.findOne().then((model,err)=>{
          if(!model || err){
            lastEndTime = startTime;
            reject("not enough data to run with yet.");
            return;
          }
          resolve({startTime:model.start_time_ms, endTime:model.start_time_ms + findEventsInterval} );
        })
      }
      let endTime = startTime + findEventsInterval;
      resolve({startTime:startTime, endTime:endTime});
    });
}

function executeEventFinder(startTime,endTime){
  return new Promise(
    function (resolve, reject) {
      let args = ['run', '--rm', 'sotera/dr-manhattan:12', API_ROOT, startTime.toString(), endTime.toString()];
      console.log('running: docker', args.join(' '));

      try {
        currentJob = spawn('docker', args);
      }
      catch(err){
        console.log(err);
      }
      currentJob.stdout.on('data', data => {
        console.log(`stdout: ${data}`);
      });

      currentJob.stdout.on('exit', (code,signal) => {
        currentJob = null;
        lastEndTime = endTime;
        resolve('Job exited with code: ' + code);
      });

      currentJob.on('error', err => {
        reject('Failed to start child process' + err);
      });
    });

}

function checkJobSetStatus() {
  if(currentJob != null){
    return;
  }
  catchUpToEventsIfPossible()
  .then(startTime=>{
    return calculateJobsetTimes(startTime)})
  .then(times=>{
    executeEventFinder(times.startTime,times.endTime)})
  .catch(error => {
    console.log(error);
  });
  // if we have an ending event, run dr-manhattan
  // set previous start to end...

}
